# Προγραμματισμός Συστήματος - Εργασία 1 
# Παπαδόπουλος Χρήστος
# ΑΜ: 1115202000165

# Παραδοτέα - Εκτέλεση
    •Όλα τα ζητούμενα χωρίς κάποια παράλειψη. Δεν έχει βρεθεί κάποιο bug στη λειτουργία του προγράμματος.
    •Όλα τα προγράμματα και τα bash scripts εκτελούνται όπως περιγράφονται στην εκφώνηση.
    •Για compile εκτελέστε make all. Για καθάρισμα make clean.

# Δομές της εφαρμογής
    •Η ουρά είναι βασισμένη στον κώδικα των Δομών Δεδομένων με απαραίτητες αλλαγές και προσθήκες για τις ανάγκες της εφαρμογής. 

    •Έχει οριστεί η δομή Job η οποία περιέχει: το αναγνωριστικό κάθε δουλειάς, την δουλειά όπως δόθηκε από τον χρήστη και τη θέση •της στην ουρά, όσο αυτή είναι στην αναμονή. Όταν αρχίσει να εκτελείται, το τρίτο πεδίο μετατρέπεται στο pid της διεργασίας.

    •Στον server υπάρχουν: δύο ουρές, μία για τις δουλειές σε αναμονή(waitingJobs) και μία για όσες εκτελούνται(runningJobs), μία global μεταβλητή για το αναγνωριστικό της κάθε δουλειάς, η main και οι βοηθητικές συναρτήσεις/signal handlers:
        •void serverExit();
        •int enqueueJob(char* buffer);
        •int listAllJobs(Queue queue, int flag);
        •Job* findJob(Queue queue, char* stopId);
        •void dequeueFinishedJob(int signum);
        •void executeCommand(int signum);
    
    •Στον commander βρίσκονται η main και ο signal handler:
        •void serverReturn(int signum);

# Επεξήγηση Κώδικα
    Κάθε jobCommander που δημιουργείται ελέγχει την ύπαρξη του jobExecutorServer.txt, δηλαδή του server. Αν αυτός δεν έχει δημιουργηθεί, κάνει fork(). Το παιδί τρέχει τον σέρβερ μέσω exec() και ο πατέρας περιμένει την αρχικοποίησή του μέσω της
    waitpid(). Ο server κατά την εκτέλεση δημιουργεί τα pipes. Γίνεται forked και η διεργασία γονέας γράφει το PID της διεργασίας παιδιού στο αρχείο .txt του σέρβερ και κάνει exit, επιτρέποντας στον jobCommander να συνεχίσει την εκτέλεσή του. Το παίδι συνεχίζει σε infinite-loop τη λειτουργία του server μέχρι να γίνει exit από τον χρήστη. 
    Αν ο jobExecutorServer είναι ενεργός, ο commander διαβάζει από το .txt το pid του server και στη συνέχεια γράφει στο ένα pipe(όπου γράφουν οι commanders) το δικό του pid και τη δουλειά που θέλει να εκτελεθεί. Στη συνέχεια στέλνει μέσω kill() σήμα στον server ώστε να διαβάσει το pipe και μπαίνει σε loop μέχρι να πάρει σήμα πίσω. Όταν λάβει κάποιο σήμα από τον server, ανοίγει το άλλο pipe(όπου γράφει ο σέρβερ) και εκτυπώνει το μήνυμα που έχει γραφτεί, αν υπάρχει κάποιο.
    Ο σέρβερ λειτουργεί σε infinite loop όπου με τη σειρά ελέγχει για σήμα από commander, για σήμα από διεργασία παιδί και τέλος δρομολογεί για εκτέλεση διεργασίες, αν υπάρχουν διαθέσιμες και αν το επιτρέπει ο βαθμός παραλληλίας. Πιο συγκεκριμένα, για την εκτέλεση διεργασιών, η διεργασία μεταφέρεται από την μία ουρά στην άλλη και εκτελείται με fork()-exec() από τον server.
    Όταν ο server λάβει σήμα από κάποια διεργασία παιδί, μέσω της waitpid() βρίσκει όσες διεργασίες έχουν τελειώσει την εκτέλεσή τους και τις αφαιρεί από την ουρά. Όταν ληφθεί σήμα από τον commander, ο server ανοίγει το pipe, κάνει tokenize την εντολή και την αναγνωρίζει με strcmp() ώστε να την χειριστεί ως εξής:
        •Η εντολή issueJob μετατρέπεται σε Job struct και τοποθετείται στην waitingJobs ουρά. Αν υπάρχει δυνατότητα εκτέλεσης, θα μεταφερθεί άμεσα στην άλλη ουρά στην main. Επιστρέφεται η τριπλέτα στον commander μέσω pipe και kill().
        •Η εντολή setConcurrency αλλάζει την παραλληλία του server. Δεν επιστρέφεται κάτι στον commander, χρησιμοποιείται όμως η kill() ώστε να τον ξεμπλοκάρει.
        •Η εντολή stop βρίσκει την εντολή που έχει δοθεί μέσω της βοηθητικής συνάρτησης και αν είναι στην αναμονή την αφαιρεί από την ουρά. Αν βρίσκεται σε εκτέλεση, γίνεται fork()-exec() σε "kill" και μετά αφαιρείται και από την ουρά.
        •Η εντολή poll χρησιμοποιεί την βοηθητική συνάρτηση listAllJobs για να γραφτούν στο pipe όλες οι τριπλέτες και να επιστραφούν στον commander για να εκτυπωθούν.
        •Η εντολή exit αφαιρεί από την ουρά αναμονής όλες τις δουλειές. Σταματάει την εκτέλεση όλων των διεργασιών που τρέχουν και τις αφαιρεί από την ουρά. Αποδεσμεύει τη μνήμη των ουρών. Κάνει fork()-exec() σε rm -f "jobExecutorServer.txt" και το κύριο πρόγραμμα τερματίζει.
    
# Σχόλια
    Στην εργασία υπάρχουν ορισμένα memory leaks και κάποια στατικά buffers. Δεν έχουν γίνει εξαντλητικοί έλεγχοι στη χρήση της εφαρμογής από τον χρήστη(π.χ. για είσοδο όπως "./jobCommander exit fashf adkfhlka akfdjl" ή "./jobCommander poll running 34 3").




